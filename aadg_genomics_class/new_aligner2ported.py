# aligner 2.0

#Mtarget="AGATCCTGTTCTGGTCAGCAGGGTGGTGACCAGAAAACAAGTTCTTCTGGTCTCCTACCTCAGTTGCAAGAAACTCAAAACTCCATTTTAAACTTTAAGCCTTATAGTATCTTCTGTTTGAGTATTTAACAAGCATTTGTTTTTCCTTGAAAATATATCCAGCCAAGACCTTATGAAGAATGTGAGCTAAAATTACGGTATTTTACTTGCCTGGAAACAGTACTTCTCAAATGTTAATGTGCATACAGGTGACTTGAGTATCTCATTAAAACGTAGATTTAGATTGTGTCTCCGGGGTGAGGTCTGAGAAACTTCATTTCTATAAAGTGATGTCAAAGTTACTGGTCTGGGGACCATGTTTTGGTGGCAAGTTGCAAGACCCCAGAGTTTCTACCCTAATGATTTATTCAATGACTCTTAGAGGTGTTATCAATCTGTTTTTAAAGCCAGGGACTTTGCCCAGGGGAAAAATGCATGCATACACACACACACACACACACACACACACACACACCCCTATGCGTACAATTTCGGAGCAATTGTGCATTCATTCAGTGAATACCTATTTAATGCACACCAAGTATCTTTCCGGGTGCTAATGACAGAGTGAGGAACAAGATAGCAAAGATGCCTGCCTTGTGGAGCTTTCATTATACTGTTGGTTGGAAGACAAACTAAGTAAATAAAGCAGGCATGTCAGCTATGATACATGCCTTAGGACAGTGTACTGCAGCCACGTGATACAGGGATTGGGTGGAGGAAGGTTTGAAGTGGCTCTTTTAAATTGTTCTGTCTGTGGAGGCATCTTGGCCAGGAACCTGAATGCCAGTATCTGGGGAAAAGCATCCTAGGTGGTAAGTTCGGAGCACCTGAAGCAGAAATGAGTTTAGTGTTTTCAAAAGTTAGAGAGAACTGGTATGGGAGGAACAGAGCGAGTGGAGGAGAGAGCAAAAGGTGAAATCCCAGAGGTAGAAGGGCCTGATCCTACAGGAGCTTGTAGGCCATGACAAGGAGGCTGCCTGCACTTGACCGAGCCCATGCTTAGATCCTAAAGGAGCCATGGCCTCCATTTAAGAACTCCAGACAGAGAATC"
#Mquery="AGAAAACCAGTTCTTCTGGTCTCCTACCTCAGTTGCAAGAAACCCAAAACTCCATTTTAAACTTTCAGCCTTATAGTATCTTCTGTTTGAGTATTTAACAAGCAGTTGTTTTTCCTTGAAAATAACCAGCCAAGGCCTTATGACGAATGTCAGCTAAAATTACGGTATTTTACTTGCCTGGAAACAGTACTTCTCAAAAGTTAATGTGCATAGTGGTAACTTGAGTATCTATCATTAAAACGTAGATTTAGATTGTGTCTCCGGGGTGAGGTCGGAGAAACTTCATCTCTATAAAGTGATGTCAAAGTTACTGGTCTGGGGACCATGTTTTGGTGGCAAGTTGCAAGAGCCGAGAGTTGCTACCCTAATGATTTATTCAATGACTCTTAGAGGTGTTATCAATCTGTTTTTAAAGGCAGGGACTTTGCCCAGGGGAAAAACGCATGCATACACACACACACACACACACACACACACACACACCCCTATGCGGACAATTTAGGAGCAATTATGCATTCATTCAGTGAATACATATTTAATGCACACCAAGTATCTTTCCGTGTGCTAATGACAGAGTGAGGAACAGTATAGCAAAGATGCCTGCCTCGTGGAGATATCATTATAACTGTTGGTTGGAAGACAACTAAGTAAATAAAGCAGGCAAGTCAGCTATGATACATGCCTTAGGACAGTGTACTGCAGCCACGTGATTCAGGGATTGGGTGGAGGAAGGTTTGAAGTGGCTCTTTTAATGTTCTGTCTGTGGAGGCATCTTGGCCAGGAACCTGAATGCCGGTATCTGGGTAAAAGCATCCTAGGTGGTAAGTTCGGAGCACCTGAAGAGAAATGAGATTAGTGAATTCAAAAGTTAGAGAGCACTGGTATGGGAGGAACAGAGCTAGTGGAGGAGAGAGCAAAAGTGAAATCCCAGAGGTAGAAGGGCCTGATCCTACAGGAGCTTGTAGGCCATGACAAAGAGGCTGCCTGCACTTGACCGAGC"
#queryCUT="AGCAGTTGTTTTTCCTTGAAAATAACCAGCCAAGGCCTTATGACGAATGTCAGCTAAAATTACGGTATTTTACTTGCCTGGAAACAGTACTTCTCAAAAGTTAATGTGCATAGTGGTAACTTGAGTATCTATCATTAAAACGTAGATTTAGATTGTGTCTCCGGGGTGAGGTCGGAGAAACTTCATCTCTATAAAGTGATGTCAAAGTTACTGGTCTGGGGACCATGTTTTGGTGGCAAGTTGCAAGAGCCGAGAGTTGCTACCCTAATGATTTATTCAATGACTCTTAGAGGTGTTATCAATCTGTTTTTAAAGGCAGGGACTTTGCCCAGGGGAAAAACGCATGCATACACACACACACACACACACACACACACACACACCCCTATGCGGACAATTTAGGAGCAATTATGCATTCATTCAGTGAATACATATTTAATGCACACCAAGTATCTTTCCGTGTGCTAATGACAGAGTGAGGAACAGTATAGCAAAGATGCCTGCCTCGTGGAGATATCATTATAACTGTTGGTTGGAAGACAACTAAGTAAATAAAGCAGGCAAGTCAGCTATGATACATGCCTTAGGACAGTGTACTGCAGCCACGTGATTCAGGGATTGGGTGGAGGAAGGTTTGAAGTGGCTCTTTTAATGTTCTGTCTGTGGAGGCATCTTGGCCAGGAACCTGAATGCCGGTATCTGGGTAAAAGCATCCTAGGTGGTAAGTTCGGAGCACCTGAAGAGAAATGAGATTAGTGAATTCAAAAGTTAGAGAGCACTGGTATGGGAGGAACAGAGCTAGTGGAGGAGAGAGCAAAAGTGAAATCCCAGAGGTAGAAGGGCCTGATCCTACAGGAGCTTGTAGGCCATGACAAAGAGGCTGCCTGCACTTGACCGAGC"
#expected_offsets = (31, 58)

Mtarget="AGTTCCCTCATCTGTAAAATGGGGGTAAAAAGTACCTACCGCATAACGCTGTGGTAAGACCAAGATAAAATAATGAATGCAATGCAAGACCTGGCACATAGTAAGTGCTCAATAAGTATCAGCTTTATTATTATTATAGACAGTCCAGGGGTGAAATGTAGACAAACAATTACAAAGAGCTGCTAGGTAGAAGCACAGCACTAGACACCGAGGCAGATCCAAAGAAAATTGTCCCTGCTCTCAAGGCTCTCACAACTAAGTTGGGGAAAGAGAAAAAATGCAGGGGTAAACAAAACAAAAATGAAAGCAATTAGAAAAGAGTCCCCTGTAAGGGATGTTCAAGGTGACTTCAATAGTTAGACACACAGTAGAGGCATTTGGGTGAAATCCGCAAGGCAAGGACAGCAACCAGTTCATCTCTGTGGCTGGGCATCAGCATAGAATCAAGCCCAAGGAGATGCTCAGGTGAGTGGCTATATAAATGCTTAAGTGTTCAGAATGGGAAAATGTGTTAAAAGACACACATGGTTTGAGAAGTGTCTTGCCACATTCTCACGGCGAAGTAATGTTAGAGGGTCATAGAGCTGGCCTGATCTAGAATCCAGGTCTGCCTGACATCAAAGCTCCCAATCTTTCAATGACATCCTGTTGCCTTCATTGATTTATCTCTAAATCTCTACAAATTCTGAAGTATAATAGGTGTCCACTCCATATTGATGGAGAGGATGGAAGGATAAGTAGATGGTGTTTGGTGAAGAGAGAGATTGACTGATGGTGAATGAGTAGTAGGTAAGTGGGTGGATAGGTGGATAGTAGATGAATGGATGGACAGTGGATAGATGCGTAAGGAATGGTCGGTGGATAGGTGGATAGTAGATGAATGGATGGACAGTGGATAGATGCATAAGGAATGGTGGGTGGATAGGTGGATAGTAGATGAATGGATGGACAGTGGATAGATGCGTAAGGAATGGTGGGTGGATAGGTGGATAGTAGATGAATGGATGGACAGTGGATAGATGATGCGTAAGGAATGGTGGGTGGATAGGTGGATAGTAGATGAATGGATGGACAGTGAATAGATGCATAAGGAATGGTGGGTGGATGAATTGTAGGTGGATGGCTAGTTGAGAGATGAGTGGA"
Mquery="ACTCTGTAAAATGGGGCTAAAAAGTACCTACCGCATAACGTTGTTGTAAAAGCAAGATAAAATAATAAATGCAATGTAAAACCTTTCACACCGTAAGTACTCAATAAGTATCAGCTTTCTTATTACTATTGACATCCAGGTGTCAAATTTAGACAAACATTTACAAGGAGCTGCTACGTAGAAGCACCACTAGGCACCGAGGCAGATCCAAAGAAAATTGTCCCTGCTCTCAAGGCTCTCACAACTAAGTTGGAGAAAAAGAAAAAATGCGGCGGTAAACAAACCTAAAATTGAAAGCAATTAGAAAAGAGTCCCCCGTAAGGGATGTTCAAGGTGACTTGAAGTTAGATTCACATAGAGGAATTTGTGTGAAATCCGAAAGGCAAGGACAGCATCCAGTTCATCTCCGTGGCTGGGCATCAGCATAGAATCAAGCCCAAGGACATGCTCAGGTGAGTGGCTATATAACTGCTTAAGTGTGCAGCATGGGAAGAATGTGTTAAAAGACACACATGGTTTGAGTGACTTGCCGCATTCTCACGGCGAAGTAATGTTTCAGGGTCATAGAGCTGGCCTGATCTAGAATCCAGGTCTGCCTTCACATCAAAGCTCCGAATTTTTCAACGACATCCTGTTGCCTTCATTGATTTATCTTAAAATCTCTACAAACTCTGAAGTCTAATGGTGTCCACTCCATATTGATGGAGAGGATGGAAGGATAAGTAGGTGGTGTTTGGTGAAGAGATAGATTGACTGATGGTGAATGCAGTAGTACATGTAATTGAGTGGATAGGTGAATAGTAGATGAATGGATGGATAGTGGATAGATGCGTAAGGAATGGTCGGTGGATAGATGGATATTAGATGAATGGATGGACAGAGGATAGATTCATAAGGAATGGTGGATGGATAGGTGTAATAGTAGATTAATGGATGGACAGTGGATTGATGCGTAAGGAATGGTGGGTGGATACGCGATAGTAGATGAATGGATGGACAG"
expected_offsets = (8, -131)

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from collections import defaultdict
import sys
import numpy as np

MAX_KMER_SIZE = 64

MAPPING_DOLLAR = 0
MAPPING = dict(
    C=1,
    A=2,
    T=3,
    G=4,
    #a=1,
    #c=0,
    #g=3,
    #G=4,
    #t=2,
    #T=3,
)

ALPHABET = set(MAPPING.values())
ALPHABET_DOLLAR = set([*ALPHABET, MAPPING_DOLLAR])

RR_MAPPING = ["C", "A", "T", "G"]

COMPLEMENT_MAPPING = {
    1: 2,
    0: 3,
    3: 0,
    2: 1,
}

MAPPING_FN = np.vectorize(MAPPING.get)
COMPLEMENT_MAPPING_FN = np.vectorize(COMPLEMENT_MAPPING.get)

MASKS = None
def generate_mask(
    kmer_len: int,
) -> int:
    global MASKS
    if not MASKS:
        MASKS = dict()
        ret = 3
        for i in range(MAX_KMER_SIZE+1):
            ret = (ret << 2) | 3
            MASKS[i] = ret
    return MASKS[kmer_len]

# actual code goes here!

# DP algorithm adapted from Langmead's notebooks
def align_dp_trace(D, x, y):
    ''' Backtrace edit-distance matrix D for strings x and y '''
    i, j = len(x), len(y)
    while i > 0:
        diag, vert, horz = sys.maxsize, sys.maxsize, sys.maxsize
        delt = None
        if i > 0 and j > 0:
            delt = 0 if x[i-1] == y[j-1] else 1
            diag = D[i-1, j-1] + delt
        if i > 0:
            vert = D[i-1, j] + 1
        if j > 0:
            horz = D[i, j-1] + 1
        if diag <= vert and diag <= horz:
            # diagonal was best
            i -= 1; j -= 1
        elif vert <= horz:
            # vertical was best; this is an insertion in x w/r/t y
            i -= 1
        else:
            # horizontal was best
            j -= 1
    # j = offset of the first (leftmost) character of t involved in the
    # alignment
    return j

def align_dp_k_edit(p, t):
    ''' Find the alignment of p to a substring of t with the fewest edits.  
        Return the edit distance and the coordinates of the substring. '''
    D = np.zeros((len(p)+1, len(t)+1), dtype=int)
    # Note: First row gets zeros.  First column initialized as usual.
    D[1:, 0] = range(1, len(p)+1)
    for i in range(1, len(p)+1):
        for j in range(1, len(t)+1):
            delt = 1 if p[i-1] != t[j-1] else 0
            D[i, j] = min(D[i-1, j-1] + delt, D[i-1, j] + 1, D[i, j-1] + 1)
    # Find minimum edit distance in last row
    mnJ, mn = None, len(p) + len(t)
    for j in range(len(t)+1):
        if D[len(p), j] < mn:
            mnJ, mn = j, D[len(p), j]
    # Backtrace; note: stops as soon as it gets to first row
    off = align_dp_trace(D, p, t[:mnJ])
    # Return edit distance and t coordinates of aligned substring
    return mn, off, mnJ


def run_match_align_dp(target, query, align_mode=1):
    for (k, step) in [(15, 11), (10, 11), (8, 5)]:
        suff_len_factor = 0.4
        suff_len_factor2 = 0.6

        print(f"align_seq(): ALIGNER_MODE {align_mode}")
        suff_len = round(len(query) * suff_len_factor)
        suff_len2 = round(len(query) * suff_len_factor2)

        target_suffix = target[suff_len-k:]
        query_suffix = query[(len(query)-suff_len):]

        edist = len(query)//9
        kmers = defaultdict(list)

        mask = generate_mask(k)

        uadd = np.frompyfunc(lambda x, y: ((x << 2) | y) & mask, 2, 1)

        # This computes values for kmers
        kmers_target = uadd.accumulate(target_suffix, dtype=object).astype(int)
        # for i in range(0, len(target)-k+1, step):
        #         kmers[np.sum(target[i:i+k])].append(i)
        for i in range(0, len(kmers_target), step):
            kmers[kmers_target[i]].append(i)

        hits = []
        kmers_query = uadd.accumulate(query_suffix, dtype=object).astype(int)
        #for i in range(0, len(query)-k+1, step+1):
            #for j in kmers[np.sum(query[i:i+k])]:
        for i in range(0, len(kmers_query), step+1):
            for j in kmers[kmers_query[i]]:
                lf = max(0, j-i-edist)
                rt = min(len(target_suffix), j-i+len(query_suffix)+edist)
                mn, soff, eoff = align_dp_k_edit(query_suffix, target_suffix[lf:rt])
                soff += lf
                eoff += lf
                if mn <= edist:
                    hits.append((mn, soff, eoff))
        hits.sort()
        if hits:
            return 0, len(target_suffix)-hits[0][2]
        if align_mode == 1:
            return 0, 0
    return 0, 0

if __name__ == '__main__':
    #print(f"align_seq default = {align_seq(Mtarget, Mquery)}")
    print(f"len(Mtarget)={len(Mtarget)} len(Mquery)={len(Mquery)}")
    print(run_match_align_dp(MAPPING_FN(np.array(list(Mtarget))), MAPPING_FN(np.array(list(Mquery))), align_mode=2))